"""
SQLAlchemy models for FinOps Intelligence Dashboard.
These models define the structure of the data stored in the PostgreSQL database.
"""

from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, Index, UniqueConstraint
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

# Base class for declarative models
# This is now the canonical Base for all models.
Base = declarative_base()


class AggregatedCostData(Base):
    """
    SQLAlchemy model for storing aggregated FinOps cost data.
    This table will hold multi-dimensional cost aggregations from BigQuery.
    """

    __tablename__ = "aggregated_cost_data"

    # Composite indexes to optimize common dashboard queries (e.g., burn rate, MTD spend)
    # that filter by a dimension (project/service) and a time range.
    __table_args__ = (
        Index("idx_cost_project_time", "project", "time_period"),
        Index("idx_cost_service_time", "service", "time_period"),
        UniqueConstraint(
            "service", "project", "sku", "time_period", name="uq_aggregated_cost_data"
        ),
    )

    id = Column(Integer, primary_key=True, index=True)
    service = Column(
        String,
        index=True,
        nullable=False,
        comment="Google Cloud service, e.g., 'Compute Engine'",
    )
    project = Column(
        String, index=True, nullable=True, comment="Google Cloud project ID"
    )
    sku = Column(
        String,
        index=True,
        nullable=False,
        comment="Stock Keeping Unit, representing a specific usage metric",
    )
    time_period = Column(
        DateTime,
        index=True,
        nullable=False,
        comment="Timestamp for the aggregated period (e.g., daily, monthly)",
    )
    cost = Column(
        Float, nullable=False, comment="Aggregated cost for the given dimensions"
    )
    currency = Column(
        String, default="USD", nullable=False, comment="Currency of the aggregated cost"
    )
    usage_amount = Column(Float, nullable=True, comment="Amount of usage for the SKU")
    usage_unit = Column(
        String, nullable=True, comment="Unit of usage (e.g., 'hour', 'GB')"
    )
    created_at = Column(
        DateTime,
        default=datetime.utcnow,
        comment="Timestamp when this record was created",
    )
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        comment="Timestamp when this record was last updated",
    )

    # Establish a one-to-many relationship with LLMInsights
    # This allows accessing related insights directly from an AggregatedCostData object
    llm_insights = relationship("LLMInsight", back_populates="related_finops_data")

    def __repr__(self):
        return (
            f"<AggregatedCostData(id={self.id}, service='{self.service}', "
            f"project='{self.project}', sku='{self.sku}', cost={self.cost})>"
        )


class LLMInsight(Base):
    """
    SQLAlchemy model for storing LLM-generated insights.
    This table will hold automated spend summaries, anomaly detections, and cost optimization recommendations.
    """

    __tablename__ = "llm_insights"

    id = Column(Integer, primary_key=True, index=True)
    insight_type = Column(
        String,
        nullable=False,
        index=True,
        comment="Type of insight (e.g., 'spend_summary', 'anomaly_detection', 'cost_optimization')",
    )
    insight_text = Column(
        String,
        nullable=False,
        comment="The actual text content of the insight generated by the LLM",
    )

    # Foreign key to link an insight to specific aggregated cost data if applicable
    # This relationship is optional, as some insights might be general or not tied to a single data point
    related_finops_data_id = Column(
        Integer,
        ForeignKey("aggregated_cost_data.id"),
        nullable=True,
        index=True,
        comment="Foreign key to AggregatedCostData if the insight is related to specific cost data",
    )

    timestamp = Column(
        DateTime,
        default=datetime.utcnow,
        nullable=False,
        index=True,
        comment="Timestamp when the insight was generated",
    )
    sentiment = Column(
        String,
        nullable=True,
        comment="Optional sentiment of the insight (e.g., 'positive', 'negative', 'neutral')",
    )
    created_at = Column(
        DateTime,
        default=datetime.utcnow,
        comment="Timestamp when this record was created",
    )
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        comment="Timestamp when this record was last updated",
    )

    # Establish a many-to-one relationship with AggregatedCostData
    # This allows accessing the related cost data directly from an LLMInsight object
    related_finops_data = relationship(
        "AggregatedCostData", back_populates="llm_insights"
    )

    def __repr__(self):
        return (
            f"<LLMInsight(id={self.id}, insight_type='{self.insight_type}', "
            f"timestamp='{self.timestamp}', related_finops_data_id={self.related_finops_data_id})>"
        )
